# A map of the territory

## 编译器和解释器

+ 严格来说，编译是将一种类型的语言翻译为另一种(通常更低层次)语言（例如：字节码或机器码或另一种高级语言代码）的技术。
+ 编译器将源代码翻译为另一种形式而不执行。
+ 解释器以源代码作为输入并立刻执行。

## 静态分析：*动态类型*语言和静态类型语言

+ 静态分析的任务
    1. identifier binding/resolution
        + 涉及scope等概念。
    2. type checking
        + 动态类型在运行时做类型检查。
        + 注：动态类型并不全是解释型语言。例如：cpython。

## 运行时

两种形式的运行时。

+ 对于编译为机器码的语言，运行时会被直接插入最终的可执行文件。例如：c, go。
+ 对于编译为字节码的文件，虚拟机是其运行时。

## 前端的bookeeping方式

1. 静态分析后将额外的语义信息存储在语法树节点上。
2. 将数据存储在look-up table的键值对中。其键是变量名和声明。
3. 将语法树转换为新的中间表示。

## JIT技术

+ 将经常调用的代码（虚拟机字节码）运行时翻译为机器代码
+ 对于动态类型语言来说，JIT技术是实现它们的最快的方式。但是实现方式相对复杂，例如对于cpython就没有实现JIT，而pypy实现JIT。

## challenge

### lisp为什么同时带有一个解释器和一个编译器？

首先，lisp的解释器将lisp源文件翻译为另一种语言源文件（通常是c），原因如下：

+ 解释器需要parse源文件（开销并不大）。
+ 变量求值时，需要动态查询变量的值列表。编译版本能够立刻访问该值。
+ 函数求值时，查询开销大，O(logn)复杂度。
+ 向函数传链表的开销大。
+ 无用操作，例如字符串表示到内部数字表示转换和反转换。
+ 原生代码(例如编译成java)的执行通常性能更好。

[参考](http://www.mlb.co.jp/linux/science/yacas/documentation/LispProgrammingchapter3.html)

## 总结

由于tree-walker interpreter性能太差，一般没有使用这种方式实现的语言（php3？ruby的早期版本？shell的非posix版本？）。那么对于市面上的（主流）语言，我的理解是本质上都是编译型的，即要么生成字节码，要么生成机器码，要么生成另一种高级语言。那么可以根据以下角度分类：

1. （主要）生成机器码的：c，c++，rust，go
2. （主要）生成字节码的，即使用虚拟机(作为运行时)：
    + （主要）静态类型：java
    + 动态类型：scala，python
3. （主要）生成其它高级语言的：lisp
4. （纯tree walker interpreter）：一些语言的（非主要/非商业/非最新版本）实现
